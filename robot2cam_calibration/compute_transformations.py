"""A file to calculate the pose transformation between a camera and robot and
a tool offset from correspondences.
"""

# The MIT License (MIT)
#
# Copyright (c) 2016 GTRC.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from __future__ import division
import argparse
import json
from scipy.optimize import minimize
import datetime
import os
import math
import numpy as np
import cv2

def main():
    """
    Exposes :py:func:`compute_transformation` to the commandline. Run with arg
    `-h` for more info.
    """
    # Parse in arguments
    parser = argparse.ArgumentParser(
        description="Compute transformation between camera and robot given "
                    "existing correspondences")

    parser.add_argument("--correspondences", type=str,
                        help='The filename for the file containing the list of'
                             'correspondences, which is generated by'
                             'get_correspondences.py. '
                             'Defaults to: correspondences.json',
                        default="correspondences.json")

    parser.add_argument("--out", type=str,
                        help="File to save output to",
                        default="transformation.json")

    parser.add_argument("--cam2rob", type=np.array,
                        help="Initial guess for the camera to robot transformation",
                        default=np.array([0,0,1,0,0,0]))

    parser.add_argument("--tcp2target", type=np.array,
                        help="Initial guess for the tcp to target (robot tool)",
                        default=np.array([0,.5,.5,0,0,0]))

    parser.add_argument("--max_cam2rob", type=float,
                        help="Maximum deviation of the cam2robot transformation from the guess",
                        default=5)

    parser.add_argument("--max_tcp2target", type=float,
                        help="Maximum deviation of the cam2target transformation from the guess",
                        default=1)

    args = parser.parse_args()

    compute_transformation(
        correspondences=args.correspondences,
        file_out=args.out,
        cam2rob_guess=args.cam2rob,
        tcp2target_guess=args.tcp2target,
        max_cam2rob_deviation=args.max_cam2rob,
        max_tcp2target_deviation=args.max_tcp2target
    )

# given n samples:
def compute_transformation(correspondences, file_out, cam2rob_guess,
                           tcp2target_guess, max_cam2rob_deviation,
                           max_tcp2target_deviation):
    with open(correspondences, 'r') as correspondences_file:
        correspondences_dictionary = json.load(correspondences_file)
        write_time = correspondences_dictionary['time']
        tcp2robot = correspondences_dictionary['tcp2robot'] #nx6 array x,y,z,axis-angle
        camera2grid = correspondences_dictionary['camera2grid'] #nx6 array x,y,z,axis-angle
        print("Loaded data from {}".format(write_time))

    #optimize
    guess = np.concatenate((cam2rob_guess, tcp2target_guess))
    bounds = ((guess[0] - max_cam2rob_deviation,
               guess[0] + max_cam2rob_deviation),
              (guess[1] - max_cam2rob_deviation,
               guess[1] + max_cam2rob_deviation),
              (guess[2] - max_cam2rob_deviation,
               guess[2] + max_cam2rob_deviation),
              (-np.pi, np.pi), (-np.pi, np.pi), (-np.pi, np.pi),
              (guess[6] - max_tcp2target_deviation,
               guess[6] + max_tcp2target_deviation),
              (guess[7] - max_tcp2target_deviation,
               guess[7] + max_tcp2target_deviation),
              (guess[8] - max_tcp2target_deviation,
               guess[8] + max_tcp2target_deviation),
              (-np.pi, np.pi), (-np.pi, np.pi), (-np.pi, np.pi)
              )
    result = minimize(error, guess, args=(tcp2robot, camera2grid),
                                  bounds=bounds,method='L-BFGS-B')

    # print("Tool Offset: {0}".format(G))
    # print("Camera to Robot: {0}".format(R))
    #
    # json_dict = {"time": str(datetime.datetime.now()),
    #              "tcp2robot": G,
    #              "camera2grid": R}
    # with open(os.path.join(os.path.splitext(file_out)[0], '.json'), 'w') as \
    #         result_json_file:
    #     json.dump(json_dict, result_json_file, indent=4)

    json_dict = {"time": str(datetime.datetime.now()),
                 "cam2robot": {"xyz-angle": result.x[:6].tolist(),
                               "Tmatrix": vector2mat(result.x[:6]).tolist()},
                 "tcp2target": {"xyz-angle": result.x[6:].tolist(),
                                "Tmatrix": vector2mat(result.x[6:]).tolist()}
                 }

    with open(os.path.splitext(file_out)[0] + '.json', 'w') as result_json_file:
        json.dump(json_dict, result_json_file, indent=4)

def error(guess, tcp2robot, camera2grid):
    """
    Calculates the difference between a guess at robot 2 cam transformations
    compared to gathered data.

    Args:
        guess (1x12 array): Input guess array. Values will range between the bounds
                            passed in the optimize function. 6 dof camera 2 robot
                            (x,y,z,axis-angle), 6 dof tcp 2 target
                            (x,y,z,axis-angle)
        tcp2robot (nx6 array): Array of gathered data for the pose of the robot
                               tool center point wrt. the robot coordinate base
        camera2grid (nx6 array): Array of gathered data for the transformation
                                 from the camera to the target

    Returns: A float, the average error between the guess and the collected
             data
    """
    total_error = 0
    for i in range(len(tcp2robot)):
        guess_cam2rob = vector2mat(guess[:6])
        guess_tcp2target = vector2mat(guess[6:])
        guess_cam2tcp = np.matmul(guess_cam2rob, vector2mat(np.array(tcp2robot[i])))
        guess_cam2target = np.matmul(guess_cam2tcp, guess_tcp2target)
        errorvec = np.array(mat2vector(guess_cam2target))-np.array(camera2grid[i])
        for j in range(0,len(errorvec)):
            total_error+=math.pow(errorvec[j],2)
        total_error=math.sqrt(total_error)
        # total_error += abs(sum(
        #     np.array(mat2vector(guess_cam2target))-np.array(camera2grid[i])
        # ))

    return total_error/guess.shape[0]

def vector2mat(vector):
    """
    Converts a vector in form x,y,z,axis-angle to a homogenous transformation
    matrix

    Args:
        vector (6 element list): a vector representation form of a
                                 transformation matrix. x,y,z,axis-angle

    Returns: A 4x4 np.ndarry of the homogenous transformation matrix
    """
    transformation_matrix = np.zeros((4,4))
    transformation_matrix[3, 3] = 1
    transformation_matrix[0:3,3] = vector[:3]
    rotation_matrix, _ = cv2.Rodrigues(vector[3:])
    transformation_matrix[:3,:3] = rotation_matrix
    return transformation_matrix

def mat2vector(mat):
    """
    Converts a transformatiion matrix into a 6 dof vector. x,y,z,axis-angle
    Args:
        mat (4x4 ndarray): the transformation matrix

    Returns: A 6 element list, x,y,z,axis-angle
    """
    vector = [0]*6
    vector[:3] = np.asarray(mat[:3,3])
    axis_angle, _ = cv2.Rodrigues(mat[:3,:3])
    vector[3:] = axis_angle
    return vector

#if __name__ == "__main__":
    #main()

correspondences = '../examples/correspondences_may10.json'
file_out = 'computed_transformations_may10'
#cam2rob_guess = np.array([0.,0.,0.,0.,0.,0.])
#tcp2target_guess = np.array([0.,0.,0.,0.,0.,0.])
cam2rob_guess = mat2vector(np.matrix([[-.7152,.6985,-.0243,178.2],[.0412,.0074,-.9991,724.3],[-.6978,-.7155,-.0341,1515.7],[0.,0.,0.,1.]]))
tcp2target_guess = mat2vector(np.matrix([[.0189,.9998,.0049,-206.5],[.9998,-.0189,-.0027,-71.1],[-.0026,.005,-1.,2.5],[0.,0.,0.,1.]]))
max_cam2rob_deviation = 2000
max_tcp2target_deviation = 500
compute_transformation(correspondences, file_out, cam2rob_guess,
                       tcp2target_guess, max_cam2rob_deviation,
                       max_tcp2target_deviation)